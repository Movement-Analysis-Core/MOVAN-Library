function [smoothfreq,smoothdata,SNR] = smoothWinter20200820(data,datafreq,order,plotoption)% [smoothfreq,smoothdata,SNR] = smoothWinter20200820(path,data,datafreq,order,plotoption)% inputs  - data, single column time series%         - datafreq, sampling frequency%         - order, order of the butterworth filter%         - plotoption, boolean: 1 to create plot, 0 to not create plot% outputs - smoothfreq, calculated frequency cut-off%         - smoothdata, single column time series of smoothed data%         - SNR, signal-to-noise ration of the time series% Remarks% - This code uses the method described in the reference to select an%   appropriate frequency cut-off for a low-pass filter. There are a number%   of cases where a line of best fit can be hard to find. It's recommended%   the plots are created and saved so they can be reviewed later.% - This code has been corrected and modified from the original%   Smooth_all.m code used in the PAD project.% - Refer to the reference for details on the method.% Future Work% - Further validation could be done to ensure cut-offs are selected%   appropriately for varies data.% References% - Winter, D.A. (2005) Biomechanics and motor control of human movement.%   4rd Ed. Hoboken, NJ: John Wiley & Sons, Inc. pg. 70-73% Prior - Created by Jung Chien, Jenna Yentes and Shane Wurdeman% Jan 2015 - Modified by John McCamley%          - Modified from the smooth.m code supplied by Jung Chien on%            1-20-2015% Oct 2016 - Modified by Ben Senderling%          - Automated the linear region selection. Added SNR, plotting.% Aug 2017 - Modified by Ben Senderling%          - Adjusted the part of the code that looks for negative slopes%            in the r^2 values to also find slopes less than 0.001 in%            magnitude.% Aug 2018 - Modified by Ben Senderling%          - Changed to use FiltFiltM from MATLAB File Exchange. It's%            faster.% Aug 2020 - Modified by Ben Senderling, bmchmovan@unomaha.edu%          - Removed auto-updating code.%% Copyright 2020 Movement Analysis Core, Center for Human Movement% Variability, University of Nebraska at Omaha%% Redistribution and use in source and binary forms, with or without % modification, are permitted provided that the following conditions are % met:%% 1. Redistributions of source code must retain the above copyright notice,%    this list of conditions and the following disclaimer.%% 2. Redistributions in binary form must reproduce the above copyright %    notice, this list of conditions and the following disclaimer in the %    documentation and/or other materials provided with the distribution.%% 3. Neither the name of the copyright holder nor the names of its %    contributors may be used to endorse or promote products derived from %    this software without specific prior written permission.%% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS % IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR % PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR % CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, % EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, % PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR % PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF % LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING % NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS % SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.%%maxfr = floor((datafreq-1)/2); % maximum frequency that can be usedtf = [0.5,1:maxfr]'; % cutoff frequencies to test%% Smooth data and find RMS errorfor j = 1:length(tf)    [b,a] = butter(order,2*tf(j)/datafreq, 'low');    temp_smooth(:,j) = filtfilt(b, a, data);    %temp_smooth(:,j) = FiltFiltM(b, a, data);    error_data(j,1)=rms(abs(temp_smooth(:,j)-data));end%% Calculate linear fits for linear reagionbuffer=3;for i=length(error_data)-buffer:-1:1    p(i,:)=polyfit(tf(i:end),error_data(i:end),1); % linear fit    r2(i)=1-sum((error_data(i:end)-polyval(p(i,:),tf(i:end))).^2)/sum((error_data(i:end)-mean(error_data(i:end))).^2); % equation for r squaredend%% Find best fiti=2:length(r2)-1;negslope=find(p(i,1)<0.0001)+1; % make sure the slope is negativebestfitfreq=find(r2(negslope-1)<r2(negslope) & r2(negslope)>r2(negslope+1) & r2(negslope)>0.8,1)+negslope(1)-1; % find relative maxima with r2>0.8if isempty(bestfitfreq) % if no relative maxima found check if there is a best fit with a high r squared value    bestfitfreq=find(r2(negslope)>0.9,1)+negslope(1)-1;endif isempty(bestfitfreq) % if still nothing found check for a relative maxima with an r squared above 0.7    bestfitfreq=find(r2(negslope-1)<r2(negslope) & r2(negslope)>r2(negslope+1) & r2(negslope)>0.7,1)+negslope(1)-1;endif isempty(bestfitfreq) % if still nothing found check for a relative maxima with an r squared above 0.6    bestfitfreq=find(r2(negslope-1)<r2(negslope) & r2(negslope)>r2(negslope+1) & r2(negslope)>0.6,1)+negslope(1)-1;endif isempty(bestfitfreq) % if still nothing found check for a relative maxima with an r squared above 0.5    bestfitfreq=find(r2(negslope-1)<r2(negslope) & r2(negslope)>r2(negslope+1) & r2(negslope)>0.5,1)+negslope(1)-1;endif isempty(bestfitfreq) % if still nothing found check for a relative maxima with an r squared above 0.4    bestfitfreq=find(r2(negslope-1)<r2(negslope) & r2(negslope)>r2(negslope+1) & r2(negslope)>0.4,1)+negslope(1)-1;endif isempty(bestfitfreq) % if still nothing found check for any relative maxima    bestfitfreq=find(r2(negslope-1)<r2(negslope) & r2(negslope)>r2(negslope+1),1)+negslope(1)-1;endtime=(0:1/datafreq:(length(data)-1)/datafreq)'; % time vector for plotsif isempty(bestfitfreq) && plotoption==1    subplot(3,2,1),plot(tf(1:end-buffer),r2)    xlabel('starting data points'), legend('r squared'), axis tight    subplot(3,2,2),plot(tf(1:end-buffer),p(:,1),'.',tf(1:end-buffer),p(:,2),'.')    xlabel('frequency (Hz)'), legend('slopes','intercepts'), axis tight    subplot(3,2,[3,4]),plot(time,data,'b')    xlabel('time (s)'), ylabel('data'), axis tight    subplot(3,2,[5,6]),plot(tf,error_data)    xlabel('frequency (Hz)'), ylabel('RMS'), axis tight        warning('line of best fit not found')    smoothfreq=999;    smoothdata=999;    SNR=999;    returnendif p(bestfitfreq,1)>0 && p(bestfitfreq,1)<0.0001 && p(bestfitfreq,2)<0    p(bestfitfreq,2)=0.001;endsmoothfreqind=find(error_data<=p(bestfitfreq,2),1); % finds error data point below the y intercept of the best fit linesmoothfreq = tf(smoothfreqind); % calculated cut-off frequencysmoothdata = temp_smooth(:,smoothfreqind); % data that was smoothed at that frequencySNR=(max(error_data)-p(bestfitfreq,2))/p(bestfitfreq,2); % signal-to-noise ratioif plotoption==1 % spit out fansy plots    subplot(3,2,1),plot(tf(1:end-buffer),r2,tf(bestfitfreq),r2(bestfitfreq),'ro')    xlabel('starting data points'), legend('r squared','best fit'), axis tight    subplot(3,2,2),plot(tf(1:end-buffer),p(:,1),'.',tf(1:end-buffer),p(:,2),'.',tf(bestfitfreq),p(bestfitfreq,1),'ro',tf(bestfitfreq),p(bestfitfreq,2),'ro')    xlabel('frequency (Hz)'), legend('slopes','intercepts'), axis tight    subplot(3,2,[3,4]),plot(time,data,'b',time,smoothdata,'r')    xlabel('time (s)'), ylabel('data'), axis tight    subplot(3,2,[5,6]),plot(tf,error_data,'b*',[0:1:max(tf)],polyval(p(bestfitfreq,:),0:1:max(tf)),'r',tf(bestfitfreq:end),error_data(bestfitfreq:end),'ro')%,[0 smoothfreq],[error_data(smoothfreqind) error_data(smoothfreqind)],'g',[tf(smoothfreqind) tf(smoothfreqind)],[0 max(error_data)],'k')    xlabel(['frequency (Hz), order = ' num2str(order) ', fc = ' num2str(smoothfreq)]), ylabel('RMS'), axis tight    end